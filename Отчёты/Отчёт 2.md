# Проектирование Базы Данных: Нормализация и Целостность

## 1. Соответствие Требованиям Нормализации

Проектирование базы данных для системы учета заявок на ремонт бытовой техники выполнено с соблюдением принципов нормализации, в частности, достигнута **Третья Нормальная Форма (3НФ)** .

### 1.1. Достижение 3НФ

| Нормальная Форма | Принцип | Реализация в Схеме (`table.sql`) |
| --- | --- | --- |
| **1НФ** | Устранение повторяющихся групп и атомарность значений. | Каждая ячейка содержит одно значение. Например, таблица `requests` содержит отдельные поля для `model`, `serial_number` и `description`. |
| **2НФ** | Достижение 1НФ и устранение частичных зависимостей. | Все неключевые атрибуты полностью зависят от первичного ключа. Например, `full_name` клиента зависит только от `client_id` в таблице `clients`, а не от составного ключа. |
| **3НФ** | Достижение 2НФ и устранение транзитивных зависимостей. | Устранение зависимостей неключевых атрибутов от других неключевых атрибутов. Например, `type_name` (название типа техники) вынесено в отдельную таблицу `equipment_types`, а в `requests` хранится только внешний ключ `type_id`. |

## 2. Обеспечение Ссылочной Целостности

Ссылочная целостность реализована через систему внешних ключей (Foreign Keys, FK) с четко определенными ограничениями `ON DELETE` .

### 2.1. Анализ Ограничений Внешних Ключей

| Таблица-Потомок | Поле FK | Таблица-Родитель | Ограничение `ON DELETE` | Обоснование |
| --- | --- | --- | --- | --- |
| `requests` | `client_id` | `clients` | **RESTRICT** | Нельзя удалить клиента, пока на него есть активные или завершенные заявки. Это обеспечивает сохранность истории. |
| `requests` | `master_id` | `masters` | **SET NULL** | Если мастер увольняется (удаляется из `masters`), его заявки не удаляются, а поле `master_id` обнуляется. Это позволяет переназначить заявку и сохранить данные. |
| `requests` | `type_id` | `equipment_types` | **RESTRICT** | Нельзя удалить тип техники, пока он используется в заявках. |
| `requests` | `status_id` | `statuses` | **RESTRICT** | Нельзя удалить статус, пока он используется в заявках. |
| `comments` | `request_id` | `requests` | **CASCADE** | При удалении заявки все связанные с ней комментарии должны быть автоматически удалены. |

## 3. Схема Именования и Индексирование

### 3.1. Согласованная Схема Именования

Вся схема базы данных (`table.sql` ) использует единый стиль именования:

- **Таблицы:** Множественное число, нижний регистр, `snake_case` (например, `equipment_types`, `requests`).

- **Поля:** Нижний регистр, `snake_case` (например, `request_id`, `full_name`).

- **Ключи:** Первичные ключи именуются как `[table_name]_id` (например, `client_id`).

### 3.2. Оптимизация Производительности через Индексы

Для ускорения операций поиска и соединения (JOIN) по внешним ключам и часто используемым полям были созданы некластеризованные индексы:

```sql
CREATE INDEX idx_requests_client_id ON requests (client_id);
CREATE INDEX idx_requests_master_id ON requests (master_id);
CREATE INDEX idx_requests_status_id ON requests (status_id);
CREATE INDEX idx_clients_phone_number ON clients (phone_number);
CREATE INDEX idx_requests_date_created ON requests (date_created);
```

## 4. Реализация Заполнения Данных (Импорт)

Скрипт `import_data.py` отвечает за перенос данных из CSV-файлов в базу данных.

### 4.1. Обработка Конфликтов и Последовательностей

В скрипте предусмотрена логика для корректной работы с автоинкрементными полями (SERIAL) в PostgreSQL:

> "Обновляем последовательность request_id до максимального значения + 1. Это необходимо, чтобы избежать конфликтов при создании новых заявок" [3]

Это гарантирует, что после импорта данных, которые могут содержать заданные ID, следующая автоматически созданная запись получит корректный уникальный идентификатор.

